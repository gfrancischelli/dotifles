" 0.    Vimrc & Appearence ------------------------------------------------- {{{

set foldmethod=marker
execute pathogen#infect()
filetype plugin indent on
syntax on

set t_Co=256
set background=dark
colorscheme illumicolor

" Italics on comments and html attrs
highlight Comment gui=italic
highlight Comment cterm=italic
highlight htmlArg gui=italic
highlight htmlArg cterm=italic

" Wider line height
set linespace=5

"SnipMate
" imap <L  <esc>a<Plug>snipMateNextOrTrigger
" smap <C-H> <Plug>snipMateNextOrTrigger

" JSX in .js files (for riotjs templating)
let g:jsx_ext_required = 0

map <F10> :echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<'
\ . synIDattr(synID(line("."),col("."),0),"name") . "> lo<"
\ . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"<CR>


"  }}} 
" 1.    Basic Options ------------------------------------------------------ {{{

" Brazilian keyboard better navigation
nnoremap j h
nnoremap k j
nnoremap l k
nnoremap ç l

vnoremap j h
vnoremap k j
vnoremap l k
vnoremap ç l

inoremap jk <ESC>
set cursorline
set autoindent
set showmode
set showcmd
set hidden
set visualbell
set ttyfast
set ruler
set backspace=indent,eol,start
set number
set norelativenumber
set laststatus=2
set history=1000
set undofile
set undoreload=10000
"set list
"set listchars=tab:▸\ ,eol:¬
set matchtime=3
set splitbelow
set splitright
set autowrite
set autoread
set shiftround
set title
set linebreak
set lazyredraw
set showbreak=↪


set relativenumber


" Don't redraw while running macros
set lazyredraw 

" Set to auto read when a file is changed from the outside
set autoread

":W sudo saves the file
" (useful for handling thr permission-denied error)
cnoremap W w !sudo tee % > /dev/null

" Leader
let mapleader = "\<Space>"
let maplocalleader = "\\"

" }}}
" 2.    Selecting ---------------------------------------------------------- {{{

" select word under cursor
:map <space> viw "

" Time out on key codes but not mappings.
" Basically this makes terminal Vim work sanely.
set notimeout
set ttimeout

" Toggle Rainbow Parentheses
nnoremap <leader>R :RainbowParenthesesToggle  
" }}}
" 3.    VIM User Interfaces ------------------------------------------------ {{{

set antialias                            " 256-color palletes
set guifont=Operator\ Mono\ Light\ 11    " Sexy font


" Add a bit extra margin to the left
set foldcolumn=1

" Vim Indent Guides
set ts=2 sw=2 et
autocmd bufenter * let g:indent_guides_guide_size=2
let g:indent_guides_auto_colors=0
let g:indent_guides_start_level=2
let g:indent_guides_guide_size=1
let g:indent_guides_enable_on_vim_startup = 1

" gvim Alt key free to mappings
set winaltkeys=no

" Remove unecessary gvim UI
set guioptions-=l
set guioptions-=L
set guioptions-=r
set guioptions-=R
set guioptions-=b
set guioptions-=T
set guioptions+=c
"   }}}
" 4.    Visual mode related ------------------------------------------------ {{{

" Pressing * or # searches for the current selection
" Super useful! From an idea by Michael Naumann
vnoremap <silent> * :<C-u>call VisualSelection('', '')<CR>/<C-R>=@/<CR><CR>
vnoremap <silent> # :<C-u>call VisualSelection('', '')<CR>?<C-R>=@/<CR><CR>

" }}}
" 5.    Editing  ----------------------------------------------------------- {{{

" Add ; or , at the and of the line 
" then enter Normal Mode
inoremap <leader>a, <esc>A,<esc>
inoremap <leader>a; <esc>A;<esc>

" Move line up and down
noremap <leader>l <esc>ddlP
noremap <leader>k <esc>ddkP

" Yank to end of line
nnoremap Y y$

" Reselect last-pasted text
nnoremap gv `[v`]

" Clean trailing whitespace
nnoremap <leader>ww mz:%s/\s\+$//<cr>:let @/=''<cr>`z`

" Insert line above or below while in insert mode
imap çk <Esc>o
imap çl <Esc>O

" Fold tag function  (i.e html)
nnoremap <leader>ft Vatzf

" Sort CSS properties
nnoremap <leader>S ?{<CR>jV/^\s*\}?$<CR>k:sort<CR>:noh<CR>



" Vim Easy Align Plugin

" Start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)



" Tab completion
" will insert tab at beginning of line,
" will use completion if not at beginning
set wildmode=list:longest,list:full
set complete=.,w,t
function! InsertTabWrapper()
    let col = col('.') - 1
    if !col || getline('.')[col - 1] !~ '\k'
        return "\<tab>"
   else
        return "\<c-p>"
    endif
endfunction
inoremap <Tab> <c-r>=InsertTabWrapper()<cr>
" }}}
" 5.    Auto Complete {{{
" Hyper term fucks my c-x
inoremap çxl  <C-x>
" }}}
" 6.    Text, tab and indent related --------------------------------------- {{{

" Tabs, spaces and wrappings
set tabstop=8
set shiftwidth=2
set softtabstop=2
set expandtab
set wrap
set textwidth=80
set formatoptions=qrn1j

" Leader lt maps to last tab
let g:lasttab = 1
nmap <Leader>lt :exe "tabn ".g:lasttab<CR>
autocmd TabLeave * let g:lasttab = tabpagenr()

" Pug especific
"au FileType pug set softtabstop=2
"au FileType pug set shiftwidth=2
" }}}
" 7.    Convenience mappings ----------------------------------------------- {{{

" Opens vimrc in vertical split
nnoremap <leader>ev :vsplit $MYVIMRC<cr>
nnoremap <leader>sv :source $MYVIMRC<cr>

nnoremap <leader>i :vsplit ~/.vim/bundle/vim-asimov/colors/illumicolor.vim<cr><cr>

" Panic Button
nnoremap <f9> mzggg?G`z

" Keep the cursor in place while joining lines
nnoremap J mzJ`z

" Fuck you, help key.
noremap  <F1> :checktime<cr>
inoremap <F1> <esc>:checktime<cr>

" Kill window
nnoremap K :q<cr>

" Save
nnoremap s :w<cr>

" Toggle line numbers
nnoremap <leader>n :setlocal relativenumber!<cr>

" Tab Navigation
nnoremap <leader>( :tabprev<cr>
nnoremap <leader>) :tabnext<cr>

" Wrap
nnoremap <leader>W :set wrap!<cr>

" }}}
" 8.    Searching and Moving ----------------------------------------------- {{{
set number

" Brazilian keyboard better navigation
nnoremap j h
nnoremap k j
nnoremap l k
nnoremap ç l

" Ack search
nnoremap <leader>a :Ag

" Set Mark
nnoremap <leader>m `

" Use sane regexes.
nnoremap / /\v
vnoremap / /\v

set ignorecase
set smartcase
set incsearch
set showmatch
set hlsearch
set gdefault

set scrolloff=3
set sidescroll=1
set sidescrolloff=10

" Open new vertical split and switches to it
nnoremap <leader>w <C-w>v<C-w>l

" Easy buffer navigation
noremap <C-j> <C-w>h
noremap <C-k> <C-w>j
noremap <C-l> <C-w>k
noremap ,çç   <C-w>l

" move to beginning | end of line
nnoremap B ^
nnoremap E $

" Split new vertical buffer
noremap <leader>v <C-w>v

" Keep search matches in the middle of the window.
nnoremap n nzzzv
nnoremap N Nzzzv

" Basically, <c-]> jumps to tags (like normal) and <c-\> opens the tag in a new
" split instead.
"
" Both of them will align the destination line to the upper middle part of the
" screen.  Both will pulse the cursor line so you can see where the hell you
" are.  <c-\> will also fold everything in the buffer and then unfold just
" enough for you to see the destination line.
function! JumpToTag()
    execute "normal! \<c-]>mzzvzz15\<c-e>"
    execute "keepjumps normal! `z"
    Pulse
endfunction
function! JumpToTagInSplit()
    execute "normal! \<c-w>v\<c-]>mzzMzvzz15\<c-e>"
    execute "keepjumps normal! `z"
    Pulse
endfunction
nnoremap <c-]> :silent! call JumpToTag()<cr>
nnoremap <c-\> :silent! call JumpToTagInSplit()<cr>" }}}
" 9.    COPY PASTA --------------------------------------------------------- {{{

" Access clipboard Paste and Yank
nnoremap <leader>c "+

" Reselect pasted text
nnoremap <leader>v V`]

" Toggle auto-indenting for code paste
nnoremap <F2> :set invpaste paste?<CR>
set pastetoggle=<F2>
set showmode

" NeoComplete Enable
let g:neocomplete#enable_at_startup = 1
" }}}
" 10.   Folding ------------------------------------------------------------ {{{

set foldlevelstart=0

" Space to toggle folds.
" nnoremap <Space> za
" vnoremap <Space> za

" Make zO recursively open whatever fold we're in, even if it's partially open.
nnoremap zO zczO

" 'Focus' the current line.  Basically:
"
" 1. Close all folds.
" 2. Open just the folds containing the current line.
" 3. Move the line to a little bit (15 lines) above the center of the screen.
" 4. Pulse the cursor line.  My eyes are bad.
"
" This mapping wipes out the z mark, which I never use.
"
" I use :sus for the rare times I want to actually background Vim.
nnoremap <c-z> mzzMzvzz15<c-e>`z:Pulse<cr>

function! MyFoldText() " {{{
    let line = getline(v:foldstart)

    let nucolwidth = &fdc + &number * &numberwidth
    let windowwidth = winwidth(0) - nucolwidth - 3
    let foldedlinecount = v:foldend - v:foldstart

    " expand tabs into spaces
    let onetab = strpart('          ', 0, &tabstop)
    let line = substitute(line, '\t', onetab, 'g')

    let line = strpart(line, 0, windowwidth - 2 -len(foldedlinecount))
    let fillcharcount = windowwidth - len(line) - len(foldedlinecount)
    return line . '…' . repeat(" ",fillcharcount) . foldedlinecount . '…' . ' '
endfunction " }}}
set foldtext=MyFoldText()

" }}}" 
" 11.   NerdTree Settings -------------------------------------------------- {{{

" Refresh NerdTree Folders
nmap <Leader>r :NERDTreeFocus<cr> \| R \| <c-w><c-p>

map <Leader>N :NERDTreeToggle<CR>
autocmd bufenter * if (winnr("$") == 1 && 
                    \ exists("b:NERDTreeType") &&
                    \ b:NERDTreeType == "primary") | q | endif


let NERDTreeHighlightCursorline = 1
let NERDTreeIgnore = ['\~$', '.*\.pyc$', 'pip-log\.txt$', 'whoosh_index',
                    \ 'xapian_index', '.*.pid', 'monitor.py', '.*-fixtures-.*.json',
                    \ '.*\.o$', 'db.db', 'tags.bak', '.*\.pdf$', '.*\.mid$',
                    \ '^tags$',
                    \ '.*\.bcf$', '.*\.blg$', '.*\.fdb_latexmk$', '.*\.bbl$', '.*\.aux$', '.*\.run.xml$', '.*\.fls$',
                    \ '.*\.midi$']

let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
let NERDChristmasTree = 1
let NERDTreeChDirMode = 2
let NERDTreeMapJumpFirstChild = 'gK'

" }}}
" 12.   Backups ------------------------------------------------------------ {{{

set backup                        " enable backups
set noswapfile                    " it's 2013, Vim.

set undodir=~/.vim/tmp/undo//     " undo files
set backupdir=~/.vim/tmp/backup// " backups
set directory=~/.vim/tmp/swap//   " swap files"

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&undodir))
    call mkdir(expand(&undodir), "p")
endif
if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir), "p")
endif
if !isdirectory(expand(&directory))
    call mkdir(expand(&directory), "p")
endif
" }}}
" 13.   Fugitive ----------------------------------------------------------- {{{

nnoremap <leader>gd :Gdiff<cr>
nnoremap <leader>gs :Gstatus<cr>
nnoremap <leader>gw :Gwrite<cr>
nnoremap <leader>ga :Gadd<cr>
nnoremap <leader>gb :Gblame<cr>
nnoremap <leader>gco :Gcheckout<cr>
nnoremap <leader>gci :Gcommit<cr>
nnoremap <leader>gm :Gmove<cr>
nnoremap <leader>gr :Gremove<cr>
nnoremap <leader>gl :Shell git gl -18<cr>:wincmd \|<cr>

" }}}
" 14.   Ctrl P ------------------------------------------------------------- {{{

let g:ctrlp_match_window = 'bottom,order:ttb'
let g:ctrlp_switch_buffer = 0
let g:ctrlp_working_path_mode = 0
let g:ctrlp_user_command = 'ag %s -l --nocolor --hidden -g ""'

let g:ctrlp_custom_ignore = '\v[\/](node_modules|target|dist)|(\.(swp|ico|git|svn))$'

" }}}
" 15.   Incsearch -------------------------------------------------------- {{{

" map /  <Plug>(incsearch-forward)
" map ?  <Plug>(incsearch-backward)
" map g/ <Plug>(incsearch-stay)

map <Leader>/ <Plug>(incsearch-easymotion-/)
map <Leader>? <Plug>(incsearch-easymotion-?)
map <Leader>/ <Plug>(incsearch-easymotion-stay)

" incsearch.vim x fuzzy x vim-easymotion

function! s:config_easyfuzzymotion(...) abort
  return extend(copy({
  \   'converters': [incsearch#config#fuzzy#converter()],
  \   'modules': [incsearch#config#easymotion#module()],
  \   'keymap': {"\<CR>": '<Over>(easymotion)'},
  \   'is_expr': 0,
  \   'is_stay': 1
  \ }), get(a:, 1, {}))
endfunction

noremap <silent><expr> <Space>/ incsearch#go(<SID>config_easyfuzzymotion())

" " }}}
" 16.   Ultisnips ---------------------------------------------------------- {{{
 
" Trigger configuration. Do not use <tab> if you use https://github.com/Valloric/YouCompleteMe.
let g:UltiSnipsExpandTrigger="<M-j>"
let g:UltiSnipsJumpForwardTrigger="<m-j>"
let g:UltiSnipsJumpBackwardTrigger="<s-tab>"

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit="vertical"

inoremap ça <c-R>=UltiSnips#ExpandSnippetOrJump()<cR>
inoremap çf <c-R>=UltiSnips#JumpBackwards()<cR>

" }}}

